# 开发规范

## 表命名规范

1.  字符范围：使用英文字母、下划线、数字进行命名，首字母必须是英文字母
2.  字符大小写：统一使用小写字母命名，避免部分数据库中大小写敏感引起的问题
3.  分段命名：多个单词间采用下划线分割，方便阅读，命名符合数据资产开发标准要求
4.  简单命名原则：避免太长的命名，命名尽可能简单，尽量使用缩写形式且能够表达命名的含义
5.  标识符：尽量避免使用\_new、\_backup等关键词做标识、备份或者创建新表时加上明确日期，例如20200101
6.  临时表命名

    1.  任务相关：在原有表明基础下增加tmp\_前缀，任务中用到多个临时表的可以增加\_step1、\_step2后缀，避免多处使用同一临时表。tmp\_dwd\_trd\_order\_ilu\_dd\_step1
    2.  任务不相关：临时表命名以tmp\_开始，后缀可以增加开发者姓名以及日期，方便后期回收临时表。tmp\_dwd\_trd\_order\_ilu\_dd\_zhangsan\_20250101
    3.  临时表可以统一放到独立的schema下
7.  一致性原则：数仓中采用一致的命名方式，同一个词语代表相同的含义，做到见名知意
8.  视图命名：v\_开头，分段命名。如：v\_dwd\_trd\_order\_ilu\_dd
9.  外表命名：\_fgn结尾，dwd\_trd\_order\_ilu\_dd\_fgn

## 字段命名规范

1.  字符范围：使用英文字母、下划线、数字进行命名，首字母必须是英文字母
2.  字符大小写：统一使用小写字母命名，避免部分数据库中大小写敏感引起的问题
3.  分段命名：多个单词间采用下划线分割，无固定层级限定
4.  禁用关键字：字段名称不能直接使用数据库的关键字或保留字
5.  简单命名原则：避免太长的命名，命名尽可能简单，尽量使用缩写形式且能够表达命名的含义
6.  预留字段：不建议在表中创建预留字段
7.  意义明确原则：字段在命名时应尽可能使用限定词前缀明确字段的业务含义，例如status、type等，需增加限定词变为user\_status,user\_type,order\_status
8.  取值范围：原则上除ods层外，字段命名应采用标准词列表中的名称，如列表中没有，需先维护标准字段列表。主要业务字段使用标准词即可

### 常规字段命名方法

| 字段类型 | 命名方法           |
| :--- | :------------- |
| 属性字段 | 使用通用单词即可，见名知意  |
| 计数字段 | <计数主体>\_cnt    |
| 比例字段 | <计数主体>\_rate   |
| 分区字段 | 日/周/月/季度/年\:dt |
| 金额字段 | <计数主体>\_amt    |
| 标识字段 | is\_<标识主体>     |
| 时间字段 | <业务主体>\_time   |
| 日期字段 | <业务主体>\_date   |
| 指标字段 | 修饰词+原子词+时间修饰   |

## 代码开发规范

1.  代码中sql语句统一使用小写。
2.  代码中应有必要的注释以增强代码的可读性
3.  代码要做到任务节点可多次重跑且结果一致
4.  查询语句中应指明查询字段和字段表别名，禁止使用select \*
5.  SQL脚本命名和脚本输出的表名保持一致，做到一张表对应一个SQL任务
6.  数据表的建表语句放在对应SQL脚本中，业务规则写在建表语句下方
7.  数据表和字段的comment信息不能缺失
8.  任务脚本配置需勾选出错重试，默认重试3次，间隔2分钟
9.  每张表中固定增加字段etl\_time代表数据生成时间，格式为yyyy-MM-dd HH\:mm\:ss
10. 代码枚举值：字段内容如是枚举列表，则需在字段备注对应的标准代码名称，例如"订单状态@order\_status"
11. 代码值转换原则：通常情况涉及代码值的字段，在表中同时存储对应代码和代码描述两个字段，代码描述字段在原始字段上加\_desc后缀，例如order\_status转换后字段为order\_status\_desc。
12. 如代码值的key为明确的英文单词，能做到见名知意，则可根据情况省略转换字段
13. 脚本中使用临时表时，需在前后分别加入drop table if exists 语句，防止多处使用同一临时表命名引起错误
14. 做truncate/drop/delete操作时，必须要提前备份，删表操作需两人以上一起执行
15. 严禁一段超长SQL处理所有业务逻辑，通用逻辑沉淀建模复用，非通用的拆分单独执行
16. 字段映射数据类型必须是兼容的，注意不能存在截取丢失精度问题
17. DATAX任务配置中，严禁选择容忍脏数据，只能选择不容忍脏数据

### SQL格式化示例

1.  每次缩进一个TAB或者4个空格
2.  同层级的SQL语句缩进保持一致，每个关键字/子查询递进一个缩进
3.  select/from/where/order by/group by等子句单独占一行，若内容较少可放在同一行
4.  算术运算符、逻辑运算符前后各保留一个空格
5.  对较复杂的SQL语句应适当注释说明业务逻辑，注释单独一行放在语句前面

```sql
select 
	a.col1,
	a.col2,
	b.col1,
	b.col2
from table_a a
left join
(
	select
		a1.col1 as col1,
    	-- 复杂逻辑注释
		b1.col1 as col2
	form table_inner_a a1
	inner join table_inner_b b1
	on a1.id = b1.id 
) b
on a.id = b.id
```

## 代码发布

非必要情况（线上问题），严禁在白天发布线上代码，白天开发+测试环境测试（包括数据测试）完成后，下班后发布代码，发布流程如下：

1.  数开人员在开发环境脚本测试成功+数据测试成功
2.  准备发布脚本，

    1.  一般将DDL和DML分为两个任务发布（涉及更新/初始化线上数据的可以单独一个脚本）
    2.  提交代码到git仓库中
3.  提交发布内容给审核人员

    1.  任务脚本
    2.  数据测试用例截图
4.  代码审核

    1.  确认符合开发规范
    2.  确认脚本完整性
    3.  复核测试结果无误
    4.  确认git仓库代码是最新版本
5.  代码发布

    1.  线上执行DDL变更（两个人一起确认操作）
    2.  发布代码
    3.  线上跑数验证

任务发布后，建议最少持续一周观察运行情况

## 运维巡检

1.  组内按周进行排班，一个人巡检一周
2.  每日上午上班时进行任务巡检，重点排查报错的任务、没运行完的任务
3.  对问题任务分类整理记录，并通知响应负责人处理
4.  跟踪处理结果，反馈领导并记录
5.  因巡检不到位导致的线上影响，根据《故障分级处理规范》和对应开发负责人共同担责

## 线上环境操作规范

1.  非必要情况，严禁在白天对线上数据进行修改删除操作
2.  非必要情况，严禁在白天手动重跑任务
3.  如需对线上数据订正，先在数仓群中通知全员，在下班业务不忙时候处理
4.  对线上数据订正时，最好两个人一起操作，每执行一步，查询下结果表是否符合预期，再执行下一步
5.  数据线上操作权限回收，代码发布权限回收，统一由管理员执行

## Doris建表规范

1.  分布键：分布键列的选择上，一般选择主键这类足够离散的列，确保数据能够均匀分布。
2.  分桶：分桶数量一般会参考CPU核数和整个表的数据量大小。一般来讲按4的倍数处理，如果单表数量较大，需确保分桶后表的单个tablet控制在2G以内
3.  主键：如果主键是3个字段以上的联合主键，则建表时可以通过md5算法生成主键ID，不建议直接使用联合主键。相应经常要关联的字段上需同步创建索引
4.  排序：业务查询中经常需要用来排序的字段，建议冗余在unique key中。doris底层使用Sort String Table存储数据表，可优化排序效率。

    drop table if exists cbebg.test;

    CREATE TABLE `cbebg`.`test`
    (
    `gmv` bigint comment '销售gmv', -- 业务中经常排序的列，放在前面并冗余在主键中
    `id` bigint COMMENT '业务主键', -- 底层存储会按主键排序，优先业务主键，再使用无意义自增键
    `item_name` string comment '商品名称',
    `etl_dt` DATETIME NOT NULL COMMENT 'ETL处理时间',
    `first_inserted_dt` DATETIME DEFAULT CURRENT\_TIMESTAMP COMMENT '记录首次插入时间',
    `last_updated_dt` DATETIME DEFAULT CURRENT\_TIMESTAMP COMMENT '记录最后更新时间'
    )
    UNIQUE KEY(`gmv`,`id`) -- 主键包含排序列
    DISTRIBUTED BY HASH(`id`)
    ;

## 模型测试规范

*   主要测试内容

    *   唯一性：验证主键数据的唯一性，确定没有重复
    *   数据范围：基于业务时间确保数据没有丢失
    *   数据格式

        *   按行抽查不同时间范围的数据，确保每个字段符合模型DDL要求
        *   按列检查枚举值字段，确保内容在数据标准内
        *   按列检查关键指标字段，确保指标数据类型正确，空值用0替代(没有NULL)，
    *   极值检查：按列检查关键字段字段，确保指标的极值在合理的边界内
    *   统计指标：按时间维度+统计维度组合，计算指标列，确保指标结果正确

## 故障分级及处理规范

### 一、故障定义

本规范所指故障为数据仓库在开发、测试、生产环境中因代码缺陷、配置错误、资源异常、依赖服务故障等原因导致的以下问题：

1.  数据异常：ETL任务失败、数据计算错误、数据不一致、数据丢失等；
2.  服务异常：数据接口不可用、调度任务阻塞、资源（CPU/内存/存储）过载等；
3.  时效异常：数据延迟超出业务容忍阈值（如报表生成超时、实时数据同步中断）；
4.  安全异常：敏感数据泄露、权限配置错误、审计日志缺失等。

### 二、故障分级标准

根据故障影响范围、业务影响程度及紧急性，将故障划分为 三级：

| 级别       | 故障类型       | 影响范围        | 判定标准                                                             |
| :------- | :--------- | :---------- | :--------------------------------------------------------------- |
| P0（严重故障） | 系统级故障      | 全业务线/核心模块   | - 数据链路中断，数据报表大面积无新数据，恢复时间>6小时 - 数据批量丢失或篡改涉及敏感信息                  |
| P1（重大故障） | 业务关键路径故障   | 单业务线/多个子系统  | - 关键报表/看板数据延迟超2小时 - ETL任务阻塞导致下游依赖任务全链路失败 - 数据偏差影响核心业务指标（如营收统计错误） |
| P2（一般故障） | 非关键功能或局部异常 | 单个子系统/非核心模块 | - 辅助报表生成失败 - 数据延迟在可容忍范围内（如T+1任务延迟<1小时） - 非敏感数据计算错误               |

### 三、线上故障处理时效要求

| 级别 | 响应时效  | 恢复时效 | 上报要求                   |
| :- | :---- | :--- | :--------------------- |
| P0 | 15分钟内 | 1小时内 | 立即通知运维及负责人，30分钟内提交应急方案 |
| P1 | 30分钟内 | 4小时内 | 1小时内书面说明故障原因及预计修复时间    |
| P2 | 2小时内  | 8小时内 | 4小时内提交初步分析报告           |

### 四、故障处理流程

1.  故障发现与上报

    *   通过监控告警（如任务状态、资源利用率、数据质量规则）或用户反馈发现故障；
    *   在故障记录表中登记故障，并标记故障级别
2.  故障应急响应

    *   P0/P1故障启动应急预案（如任务重跑、切换备用链路、临时扩容）；
    *   成立临时故障处理小组，由开发、运维、业务方代表组成。
3.  根因分析与修复

    *   72小时内完成《故障复盘报告》，内容包括：

        *   时间线还原
        *   根因分析（代码缺陷/配置错误/依赖问题）
        *   修复措施及验证结果
        *   预防方案（如新增监控项、优化ETL容错逻辑）。
4.  闭环与复盘

    *   所有故障需在5个工作日内完成整改闭环；
    *   P0/P1故障组织全员复盘会，输出改进项并跟踪落地。

### 五、追责与奖惩机制

#### 1. 责任认定

*   直接责任人：代码/配置错误的开发者或运维人员；
*   间接责任人：未及时发现缺陷的代码评审人、未配置有效监控的负责人；
*   管理责任：对高频故障未推动改进的团队主管。

#### 2. 奖惩规则

| 场景               | 奖励/惩罚措施         |
| :--------------- | :-------------- |
| 主动发现并修复潜在故障（未上线） | 表彰+绩效加分         |
| P0/P1故障处理表现突出    | 嘉奖+物质奖励         |
| 重复出现同类故障（30天内）   | 扣减绩效分，需提交专项改进计划 |
| 因重大过失导致P0故障      | 通报批评，严重者按公司制度追责 |
| 故障上报隐瞒或延迟        | 扣减团队当月质量考核分     |

## 模型使用说明

### 订单表模型

#### 一、模型基础业务信息

##### 1.1 模型名称与定义

模型名称：`dwd_order_info`（订单明细事实表）\
模型类型：明细层（DWD）事实表

元数据信息：数据平台的链接URL

开发负责人：张三\
业务定义：记录全平台所有订单的完整交易生命周期数据，涵盖订单创建、支付、发货、完成/取消等全流程状态信息，为销售分析、用户行为分析、库存管理等提供底层数据支撑。

##### 1.2 业务场景

| 场景分类   | 典型应用案例            |
| :----- | :---------------- |
| 销售分析   | 日/周/月销售额统计，区域销售排名 |
| 用户行为分析 | 用户复购率计算，客单价分析     |
| 运营监控   | 实时订单转化漏斗分析，退款率监控  |
| 财务核算   | 分账比例计算，渠道ROI分析    |

#### 二、典型使用示例

##### 2.1 日活跃订单数统计

    SELECT 
        order_date,
        COUNT(DISTINCT order_id) AS active_orders
    FROM dwd_order_info
    WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31'
      AND pay_status = 1
    GROUP BY order_date
    ORDER BY order_date;

##### 2.2 大额订单TOP100分析

    SELECT 
        order_id,
        user_id,
        total_amount,
        order_time
    FROM dwd_order_info
    WHERE total_amount > 5000
      AND order_date = '2024-03-20'
    ORDER BY total_amount DESC
    LIMIT 100;

##### 2.3 用户复购率计算

    WITH user_order_cnt AS (
        SELECT 
            user_id,
            COUNT(DISTINCT order_id) AS order_count
        FROM dwd_order_info
        WHERE order_date BETWEEN '2024-01-01' AND '2024-03-31'
          AND pay_status = 1
        GROUP BY user_id
    )
    SELECT 
        SUM(CASE WHEN order_count >= 2 THEN 1 ELSE 0 END) * 1.0 / COUNT(*) AS repurchase_rate
    FROM user_order_cnt;

***

#### 三、注意事项

##### 3.1 数据时效性

*   同步频率：T+1日更新（每日凌晨ETL作业）
*   延迟预警：若某日数据延迟超过4小时，需联系数据工程团队（Data Team）

##### 3.2 字段使用规范

*   金额类字段：所有金额单位为分（如50000表示500元）
*   状态字段：`pay_status`与`order_status`需联合判断真实状态（如支付成功但订单取消的情况）

##### 3.4 敏感信息处理

*   脱敏字段：用户手机号、身份证号等敏感信息已通过哈希加密处理
*   权限要求：访问该表需通过数据安全审批流程

##### 3.5 性能优化建议

*   分区查询：必须使用`order_date`分区字段过滤，避免全表扫描
*   复杂查询：涉及`product_ids`数组字段的查询建议使用临时表预处理

#### 四、常见问题

##### Q1：为何某天的订单量与业务系统存在差异？

A：数据仓库采用最终一致性原则，需等待订单状态完全闭环（如退款完成）后才会更新，建议对比业务系统T+1日数据。

##### Q2：如何获取订单的商品详情信息？

A：需关联维度表`dim_product_info`，通过`product_ids`字段进行JOIN操作。

##### Q3：能否直接用于实时大屏展示？

A：不建议直接使用，该表为T+1更新；如需实时数据，请使用Kafka实时计算流`realtime_order_stream`。

# 最佳实践

## DolphinScheduler离线开发

### ODS离线任务

*   约定

    *   大表：数据量在百万以上的表
    *   抽取方式：大表增量同步，小表全量同步
    *   dolphin中一个workflow确保只有一个模型表输出，可以有多个输入，确保上下游任务依赖清晰
    *   离线同步优先用DATAX配置，python代码非必要情况下尽量不用
*   合规任务依赖示例

    *   通过一个无逻辑的shell脚本控制整个库的同步开始时间，避免服务器资源征用
    *   每个任务只有一个输出，上游多个依赖
    *   出问题时，可以从问题节点重跑报错节点，以及下游所有任务

### Datax

[DorisWriter 插件文档](https://github.com/alibaba/DataX/blob/master/doriswriter/doc/doriswriter.md)

### 问题案例

1.  任务之间没依赖

    ![](https://alidocs.dingtalk.com/core/api/resources/img/5eecdaf48460cde52e24252a542d1d0925aca1aa483d200075b8339e1c4c2483f5cbb174a37b2e8c8d68742cd653602a822951806323f8966bc417fbd821daeb8fc6bc4e51f6bfb19a7b5ca772e5adaa56af425ccedf60314ecca05b3725bdf2?tmpCode=34643def-e976-4e75-bcce-d2dcde92f98e)
2.  一个workflow存在多个输出（ods和dwd在一个画布中）

    ![](https://alidocs.dingtalk.com/core/api/resources/img/5eecdaf48460cde52e24252a542d1d0925aca1aa483d200075b8339e1c4c2483f5cbb174a37b2e8c8d68742cd653602a358e919a3f95be9a9c9b02216b48236423a704c160b11ee982c458ab4837b48c406f19378b6ec960f735f51110c5f1d5?tmpCode=34643def-e976-4e75-bcce-d2dcde92f98e)
3.  一个workflow存在多个输出（多个ods在一个画布中）

![](https://alidocs.dingtalk.com/core/api/resources/img/5eecdaf48460cde52e24252a542d1d0925aca1aa483d200075b8339e1c4c2483f5cbb174a37b2e8c8d68742cd653602a60709c486a81f6b49bf60eec6293d59ff3f20b47caee3d14794c6dae08a7780c69eb81dc2f1e917fabd4b07ec9053c84?tmpCode=34643def-e976-4e75-bcce-d2dcde92f98e)

## StreamPark实时开发

[streampark官方视频](https://www.bilibili.com/video/BV17c411d7Jy/?spm_id_from=333.337.search-card.all.click)

### FlinkCDC同步

*   约定

    *   大表：数据量在千万级以上，每日变更日志在百万数据量左右
    *   上游数据库的binlog/归档日志存储时间最短要求7天
    *   针对写入/更改频繁的大表，单独做cdc同步任务，避免任务互相影响导致同步延迟
    *   小表可以整体按照整库同步的方式放在一个任务中处理
    *   针对大表需要做datax离线任务作为补救措施，在cdc任务异常时同步存量数据
    *   小表在异常时候可以直接用flinkcdc 全量+增量模式重新同步
*   同步任务

    *   cdc到Doris

    ## 主要参考 <https://zhuanlan.zhihu.com/p/680715206，重点是flink-doris-connector-1.20> jar包的参数配置

    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.doris&lt;/groupId&gt;
      &lt;artifactId&gt;flink-doris-connector-1.20&lt;/artifactId&gt;
      &lt;version&gt;25.1.0&lt;/version&gt;
    &lt;/dependency&gt;

## 模型设计

### 宽表模型

在数仓建模中，宽表模型（Wide Table Model）是一种常见的设计模式，主要用于数据集市层（Data Mart Layer），旨在通过整合多个维度和事实数据到一张表中，简化查询逻辑并提升查询性能。以下是宽表模型的详细介绍和示例：

***

#### 一、宽表模型的核心特点

1.  扁平化结构\
    将维度表和事实表通过ETL（数据抽取、转换、加载）预关联，生成一张包含所有维度属性和事实指标的宽表。
2.  减少关联操作\
    查询时无需进行多表关联（如星型模型或雪花模型中的维度表关联），直接从宽表中获取所需数据。
3.  冗余存储\
    宽表中会存储大量维度属性（如时间、地区、产品等）和事实指标（如销售额、利润等），导致数据冗余，但以空间换时间。
4.  面向业务分析\
    宽表设计通常围绕特定业务主题（如销售、客户、库存），直接支持报表、BI工具的快速分析需求。

***

#### 二、宽表模型的典型结构

宽表通常包含以下两类字段：

1.  维度属性字段

    *   来自维度表的静态属性（如产品名称、地区名称、客户姓名）。
    *   示例字段：`product_id`, `product_name`, `region`, `sales_date`, `customer_segment`。
2.  事实指标字段

    *   来自事实表的度量值（如销售额、订单数、库存量）。
    *   示例字段：`sales_amount`, `order_count`, `profit`.
3.  复合主键

    *   宽表的主键通常由业务关键字段组成（如日期+产品ID+地区ID）。

***

#### 三、宽表模型的优缺点

| 优点               | 缺点                    |
| :--------------- | :-------------------- |
| 1. 查询性能高（无需多表关联） | 1. 数据冗余导致存储成本增加       |
| 2. 简化SQL开发和BI配置  | 2. 数据一致性维护复杂（需同步更新）   |
| 3. 适合固定维度的分析场景   | 3. 扩展性差（新增维度/指标需重建宽表） |

***

#### 四、宽表模型的示例

假设需要构建一个销售分析宽表，整合销售事实与相关维度表（如日期、产品、客户、地区）。

##### 1. 源数据表结构

*   事实表（`fact_sales`）

        sales_id, product_id, region_id, customer_id, sale_date, sales_amount, profit
*   维度表

    *   `dim_product`（产品表）: `product_id`, `product_name`, `category`
    *   `dim_region`（地区表）: `region_id`, `region_name`, `manager`
    *   `dim_customer`（客户表）: `customer_id`, `customer_name`, `segment`
    *   `dim_date`（日期表）: `sale_date`, `year`, `quarter`, `month`

##### 2. 宽表设计（`wide_sales`）

通过ETL将上述表预关联，生成宽表：

    CREATE TABLE wide_sales (
        sale_date DATE,
        year INT,
        quarter INT,
        month INT,
        product_id INT,
        product_name STRING,
        category STRING,
        region_id INT,
        region_name STRING,
        manager STRING,
        customer_id INT,
        customer_name STRING,
        customer_segment STRING,
        sales_amount DECIMAL,
        profit DECIMAL
    );

##### 3. 查询示例

统计2023年Q3每个产品的销售额和利润：

    SELECT 
        product_name, 
        SUM(sales_amount) AS total_sales, 
        SUM(profit) AS total_profit
    FROM wide_sales
    WHERE year = 2023 AND quarter = 3
    GROUP BY product_name;

***

#### 五、宽表模型的应用场景

1.  固定维度分析\
    当分析需求涉及固定的维度组合（如“按产品+地区+时间”），且维度变化较少时。
2.  高性能要求\
    面向OLAP（联机分析处理）场景，需快速响应复杂查询（如BI报表、多维分析）。
3.  数据量适中\
    宽表存储成本较高，适合数据量在TB级别以内的场景（如企业级数据集市）。

***

#### 六、宽表模型的挑战与优化

1.  数据冗余管理

    *   使用压缩技术（如Parquet、ORC）减少存储开销。
    *   定期清理历史数据或归档旧数据。
2.  更新策略

    *   对缓慢变化维度（SCD）采用Type 2（新增记录）或Type 1（覆盖更新）策略。
    *   通过增量更新（Delta Load）减少全表重建成本。
3.  扩展性问题

    *   若需新增维度/指标，需重新设计宽表结构并迁移数据。

***

#### 七、宽表与星型模型的对比

| 维度    | 宽表模型         | 星型模型            |
| :---- | :----------- | :-------------- |
| 表结构   | 单表（整合维度和事实）  | 多表（事实表 + 多个维度表） |
| 查询性能  | 高（无关联）       | 中（需关联维度表）       |
| 开发复杂度 | 低（单表查询）      | 高（需多表关联）        |
| 数据一致性 | 难（冗余字段需同步更新） | 易（维度表集中管理）      |

***

#### 总结

宽表模型是数仓设计中一种以性能优先的方案，适合业务需求明确、维度稳定的场景。但其代价是存储成本增加和维护复杂度提升。在实际应用中，需根据业务需求、数据规模和资源限制权衡选择宽表或其他模型（如星型模型、雪花模型）。

### 竖表模型

#### 数仓建模中的竖表模型（Vertical Table Model）

在数仓建模中，竖表模型（Vertical Table Model）是一种将数据以"键-值对"（Key-Value）形式存储的模型，通常用于存储用户标签、动态属性或轻度汇总数据。与宽表模型（Wide Table Model）相比，竖表模型通过纵向扩展（增加行数）而非横向扩展（增加字段）来存储数据，具有更高的灵活性和扩展性。

***

##### 竖表模型 vs 宽表模型

| 维度   | 宽表模型                         | 竖表模型                        |
| :--- | :--------------------------- | :-------------------------- |
| 存储方式 | 所有字段平铺为列（如：用户ID、性别、年龄、城市...） | 数据以行存储，字段拆分为`key`和`value`两列 |
| 扩展性  | 新增字段需修改表结构，维护成本高             | 新增字段只需插入新行，无需修改表结构          |
| 查询性能 | 查询固定字段效率高                    | 需多次JOIN或子查询，性能较低            |
| 存储效率 | 稀疏字段可能导致大量空值                 | 仅存储有效数据，存储更紧凑               |
| 典型场景 | 固定维度+指标的报表（如DWD层明细表）         | 动态标签、用户画像、轻度汇总（如DWS层）       |

***

##### 竖表模型的典型应用场景

1.  用户标签系统\
    用户标签种类繁多且动态变化（如：性别、年龄、兴趣、消费能力等），竖表模型能灵活适配新增标签。
2.  DWS层轻度汇总\
    在DWS层（数据仓库汇总层），需要按用户、商品等维度聚合多类指标（如点击、购买、浏览），竖表模型可统一存储多维度指标。
3.  动态属性存储\
    对于业务规则频繁变更的场景（如营销活动标签、风控规则），竖表模型避免频繁修改表结构。

***

##### 竖表模型的具体例子：用户标签系统

假设某电商平台需要存储用户标签，标签类型包括：

*   基础属性：性别、年龄、城市
*   行为属性：最近购买时间、月均消费金额、是否会员
*   兴趣标签：运动、美妆、数码

###### 宽表模型设计（传统方式）

    CREATE TABLE user_wide (
        user_id STRING,
        gender STRING,
        age INT,
        city STRING,
        last_purchase_time TIMESTAMP,
        monthly_spend DECIMAL,
        is_vip BOOLEAN,
        interest_sport BOOLEAN,
        interest_beauty BOOLEAN,
        interest_electronics BOOLEAN
    );

问题：

*   新增一个标签（如“是否完成实名认证”）需要修改表结构。
*   多值标签（如“兴趣”有多个）无法直接存储，需拆分为多列或JSON字段。
*   若标签种类达100+，表结构臃肿，维护成本高。

###### 竖表模型设计（Vertical Table）

    CREATE TABLE user_tag (
        user_id STRING,       -- 用户ID
        tag_type STRING,      -- 标签类型（如gender、age、interest）
        tag_key STRING,       -- 标签细分维度（如sport、beauty）
        tag_value STRING,     -- 标签值（如"男"、"25"、"true"）
        update_time TIMESTAMP -- 更新时间
    );

示例数据：

| user\_id | tag\_type | tag\_key | tag\_value | update\_time     |
| :------- | :-------- | :------- | :--------- | :--------------- |
| U001     | gender    | null     | 男          | 2023-01-01 10:00 |
| U001     | age       | null     | 25         | 2023-01-01 10:00 |
| U001     | city      | null     | 北京         | 2023-01-01 10:00 |
| U001     | interest  | sport    | true       | 2023-01-01 10:00 |
| U001     | interest  | beauty   | true       | 2023-01-01 10:00 |

优点：

1.  灵活扩展：新增标签无需修改表结构，直接插入新行即可。
2.  多值支持：如用户有多个兴趣标签（sport、beauty），可存储为多行。
3.  统一管理：所有标签类型统一存储，便于维护和查询。

***

##### 竖表模型的查询示例

1.  获取用户U001的所有标签：

        SELECT tag_type, tag_key, tag_value
        FROM user_tag
        WHERE user_id = 'U001';
2.  筛选满足特定标签的用户（如：性别为男、且喜欢运动）：

        SELECT DISTINCT user_id
        FROM user_tag
        WHERE 
            (tag_type = 'gender' AND tag_value = '男') OR
            (tag_type = 'interest' AND tag_key = 'sport' AND tag_value = 'true');
3.  统计各城市的用户数量：

    SELECT tag\_value AS city, COUNT(DISTINCT user\_id) AS user\_count
    FROM user\_tag
    WHERE tag\_type = 'city'
    GROUP BY tag\_value;

***

##### 竖表模型的适用性与挑战

*   适用场景：

    *   标签/属性类型频繁变化的场景（如用户画像系统）。
    *   需要存储多值标签（如用户兴趣、商品标签）。
    *   DWS层轻度汇总（如按用户维度聚合点击、购买等行为指标）。
*   挑战：

    *   查询性能较低（需多次JOIN或子查询）。
    *   数据类型统一性差（如`tag_value`需兼容字符串、数值、布尔等）。
    *   数据冗余（`user_id`和`tag_type`可能重复存储）。

***

##### 竖表模型的优化建议

1.  分区设计：按`update_time`或`tag_type`分区，提升查询效率。
2.  物化视图：对高频查询的标签类型（如性别、城市）预聚合到宽表。
3.  分层设计：核心标签用宽表存储（如基础属性），动态标签用竖表存储。
4.  类型转换：将`tag_value`拆分为专用列（如数值型标签单独存储为DECIMAL类型）。

***

#### 总结

竖表模型通过键值对的形式解决了宽表模型在灵活性和扩展性上的不足，尤其适合用户标签、动态属性等场景。但在实际应用中需结合业务需求，平衡灵活性与查询性能，必要时与宽表模型结合使用（如核心标签用宽表，扩展标签用竖表）。

在数仓建模中，自然键和代理键是两种常见的主键设计方式，它们在处理缓慢变化维度（Slowly Changing Dimension, SCD）时有不同的应用场景和逻辑。以下是详细解释及示例：

***

### 缓慢变化维

#### 一、自然键与代理键的定义

1.  自然键（Natural Key）

    *   定义：直接来源于业务系统的业务主键，具有业务含义且唯一标识一条记录。
    *   特点：

        *   由业务规则定义（如订单号、身份证号、商品编码）。
        *   可能存在重复、格式不统一或变化的风险。
        *   适合业务稳定性高、唯一性强的场景。
2.  代理键（Surrogate Key）

    *   定义：数仓中人为生成的无意义技术主键，通常为自增整数（如 `SK_CustomerID`）。
    *   特点：

        *   由数据库自动生成，与业务无关。
        *   保证唯一性和稳定性，避免自然键变化带来的问题。
        *   常用于处理缓慢变化维度的复杂场景（如 Type 2 变化）。

***

#### 二、缓慢变化维度中的应用

缓慢变化维度的处理通常分为 Type 1、Type 2、Type 3 三种类型，代理键和自然键的组合方式因类型而异：

#### 1. Type 1：直接覆盖（Overwrite）

*   场景：维度属性发生变化时，直接覆盖旧值（不保留历史）。
*   键的使用：

    *   自然键：直接使用业务系统的自然键作为主键。
    *   代理键：无需代理键（因为不需要记录历史）。
*   示例：\
    商品表的 `商品价格` 更新时直接覆盖旧值，订单表通过 `商品编码` 关联。

#### 2. Type 2：新增记录（History Slicing）

*   场景：维度属性变化时，新增一条记录以保留历史。
*   键的使用：

    *   代理键：作为主键，唯一标识每条历史记录。
    *   自然键：作为业务键，用于关联业务系统数据。
*   示例：

        -- 商品表（Type 2）
        CREATE TABLE dim_product (
            sk_product_id INT PRIMARY KEY,       -- 代理键
            product_id VARCHAR(50),              -- 自然键
            product_name VARCHAR(100),
            effective_date DATE,
            expiry_date DATE
        );

    *   订单表：通过 `sk_product_id` 关联商品的历史版本，确保订单数据始终指向正确的商品信息。

#### 3. Type 3：新增字段（Versioning）

*   场景：通过新增字段记录变化前后的值（如 `old_value` 和 `new_value`）。
*   键的使用：

    *   自然键：作为主键。
    *   代理键：无需代理键（因为不新增记录）。
*   示例：\
    商品表新增 `previous_price` 和 `current_price` 字段记录价格变化。

***

#### 三、订单表与商品表的示例

假设业务需求为：

*   订单表需要关联商品的历史价格（Type 2 变化）。
*   商品表的 `商品名称` 和 `价格` 可能随时间变化。

#### 1. 表结构设计

    -- 商品维度表（Type 2）
    CREATE TABLE dim_product (
        sk_product_id INT PRIMARY KEY,         -- 代理键
        product_id VARCHAR(50),                -- 自然键（业务编码）
        product_name VARCHAR(100),
        price DECIMAL(10,2),
        effective_date DATE,
        expiry_date DATE
    );

    -- 订单事实表
    CREATE TABLE fact_order (
        order_id VARCHAR(50) PRIMARY KEY,      -- 自然键
        sk_product_id INT,                     -- 关联代理键
        product_id VARCHAR(50),   
        order_date DATE,
        amount DECIMAL(10,2)
    );

#### 2. 数据处理流程

*   商品信息变化时：

    *   新增一条商品记录（`sk_product_id` 自增），更新 `effective_date` 和 `expiry_date`。
    *   旧记录的 `expiry_date` 更新为当前日期，新记录的 `effective_date` 为当前日期。
*   订单表关联时：

    *   订单表通过 `sk_product_id` 关联到商品的历史版本，确保订单金额基于下单时的商品价格计算。

#### 3. 示例数据

    -- 商品维度表
    sk_product_id | product_id | product_name | price | effective_date | expiry_date
    --------------|------------|--------------|-------|----------------|------------
    1             | P001       | 笔记本       | 50    | 2023-01-01     | 2023-06-30
    2             | P001       | 电子书       | 60    | 2023-07-01     | 9999-12-31

    -- 订单事实表
    order_id | sk_product_id | order_date  | amount
    ---------|---------------|-------------|--------
    O001     | 1             | 2023-05-15  | 50      -- 关联到价格 50
    O002     | 2             | 2023-08-01  | 60      -- 关联到价格 60

***

#### 四、总结对比

| 特性    | 自然键              | 代理键            |
| :---- | :--------------- | :------------- |
| 来源    | 业务系统             | 数仓自动生成         |
| 稳定性   | 可能变化（如业务编码调整）    | 永远不变           |
| 适用场景  | 稳定、唯一的业务标识（如订单号） | 处理历史变化（Type 2） |
| 查询效率  | 高（直接关联业务系统）      | 需额外关联表         |
| 数据一致性 | 可能因变化导致历史数据错误    | 保证历史数据准确性      |

#### 五、关键建议

1.  优先使用代理键：在需要处理历史变化的维度表（如商品、客户）中，代理键是更安全的选择。
2.  保留自然键：将自然键作为业务键保留，用于与源系统对账或调试。
3.  结合 Type 2 设计：通过代理键和时间范围字段（`effective_date`/`expiry_date`）实现历史回溯。
4.  什么情况下需要缓慢变化维：维度表数据量大，变更数据量相对少，业务中需要数据的历史变化快照。使用缓慢变化维相对全量快照存储要节省较多存储成本
5.  哪些字段适合做缓慢变化：业务变化不频繁的字段，如果频繁的字段（例如商品价格）可以将字段单独

通过合理使用自然键和代理键，可以有效解决数仓中的数据一致性、历史追溯和性能优化问题。

# 遗留事项

## CK数仓下线

按开发时间、人力成本、服务器成本整体评估，建议选择分模块迁移方案。doris上线一部分，ck下线一部分，相对开发节奏稳定。服务器成本参考阿里云截图

[CK数仓下线方案讨论.axls](https://alidocs.dingtalk.com/spreadsheetv2/ZrggK0ovCgXD3qXq/edit?scene=universalSpace\&mainsiteOrigin=mainsite\&docKey=ZWGl05mLzJKBMn34\&dentryKey=ZrggK0ovCgXD3qXq\&type=s\&rnd=0.7639389491861921)

## 数据安全

已知在供应商主数据中，供应商的联系人、联系电话相关信息在数据库中都是明文存储的。建议联合信息中心一起确定公司级别的数据安全管理规定，在系统的不同环节分别做安全策略。

![](https://alidocs.dingtalk.com/core/api/resources/img/5eecdaf48460cde52e24252a542d1d0925aca1aa483d200075b8339e1c4c2483f5cbb174a37b2e8c8d68742cd653602afc228fb22ff2c4af34b1ae29f14bb5e297e1b0e5629c622a60e8c6fe044b9a8791bdd01aaf067b2f98529143646fc1a8?tmpCode=34643def-e976-4e75-bcce-d2dcde92f98e)
